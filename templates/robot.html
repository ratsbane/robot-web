<!DOCTYPE html>
<html>
<head>
    <title>Robot Arm Control</title>
    <style>
        body { font-family: sans-serif; display: flex; }
        #video-container { flex: 1; }
        #controls { width: 250px; padding: 10px; border-left: 1px solid #ccc; }
        #status { margin-top: 10px; }
        #messages { margin-top: 10px; font-weight: bold; }
        #gamepadStatus { margin-top: 10px; font-weight: bold; }
        #key-guide { margin-top: 20px; }
        #key-guide ul { list-style: none; padding: 0; }
        #key-guide li { margin-bottom: 5px; }
        #current-command { margin-top: 10px; font-weight: bold; color: blue; }
        #command-history {
            margin-top: 10px;
            border: 1px solid #ccc;
            height: 100px;
            overflow-y: scroll;
            padding: 5px;
        }
        #error-display {
            margin-top: 10px;
            color: red;
            font-weight: bold;
        }
	#motor-list { display: flex; flex-direction: column; gap: 8px; font-family: Arial, sans-serif; }
        .motor-item { display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; border-bottom: 1px solid #ddd;}
        .motor-name { font-size: 18px; font-weight: bold; color: #007BFF; }
        .motor-status { font-size: 16px; color: #28A745; }
        .motor-temp { color: #DC3545; }
        .motor-keys { font-size: 14px; color: #666; }
    </style>
</head>
<body>
    <div id="video-container">
        <h1>Robot Arm Control</h1>
        <img src="/video_feed" width="640" height="480">
        <div id="status"></div>
        <div id="messages"></div>
    </div>

    <div id="controls">
	<p id="gamepad-status">Gamepad: Not Connected ❌</p>
        <button id="gamepad-toggle" onclick="disconnectGamepad()" style="display: none;">Disconnect Gamepad</button>
<div id="motor-list">
    <div class="motor-item" id="motor-base">
        <span class="motor-name">Base</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">←/→</span>
    </div>

    <div class="motor-item" id="motor-shoulder">
        <span class="motor-name">Shoulder</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">↑/↓</span>
    </div>

    <div class="motor-item" id="motor-elbow">
        <span class="motor-name">Elbow</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">W/S</span>
    </div>

    <div class="motor-item" id="motor-wrist">
        <span class="motor-name">Wrist</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">A/D</span>
    </div>

    <div class="motor-item" id="motor-hand">
        <span class="motor-name">Hand</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">Y/H</span>
    </div>

    <div class="motor-item" id="motor-thumb">
        <span class="motor-name">Thumb</span>
        <span class="motor-status">
            <span class="motor-position">N/A</span> |
            <span class="motor-temp">N/A</span>
        </span>
        <span class="motor-keys">T/G</span>
    </div>
</div>

        <div id="current-command">Current Command: None</div>
        <div id="error-display"></div>
        <div id="command-history"></div>
        <button id="reconnectButton">Reconnect</button>
    </div>

<script>
    let socket;
    let currentCommandDisplay = document.getElementById('current-command');
    let commandHistoryDiv = document.getElementById('command-history');
    let errorDisplay = document.getElementById('error-display');
    let socketReady = false;
    let reconnectInterval = 1000; // Initial reconnect delay (1 second)
    let maxReconnectInterval = 30000; // Maximum reconnect delay (30 seconds)
    let reconnectTimeout;

    function connectSocket() {
        // Connect to the WebSocket server on port 8000
        socket = new WebSocket("ws://robot:8000/ws");  // CORRECTED URL

        socket.onopen = () => {
            document.getElementById('status').innerText = 'Connected';
            socketReady = true;
            errorDisplay.innerText = ''; // Clear errors on successful connection
            reconnectInterval = 1000; // Reset reconnect interval on successful connection
            clearTimeout(reconnectTimeout); //Clear any pending reconnect attempts.
        };


	socket.onmessage = function(event) {
            let data;
            try {
                data = JSON.parse(event.data);
            } catch (error) {
                console.error("Error parsing WebSocket message:", error);
                return;
            }

            console.log("Received data:", data); // Debugging output

            if (data.success) {
                let motorElement = document.getElementById(`motor-${data.motor}`);
                if (motorElement) {
                    motorElement.querySelector(".motor-position").innerText = data.end_position !== undefined ? data.end_position : "N/A";
                    motorElement.querySelector(".motor-temp").innerText = data.temp !== undefined ? data.temp + "°C" : "N/A";
                }
            }
        };

        socket.onclose = (event) => {
            document.getElementById('status').innerText = 'Disconnected';
            socketReady = false;
            console.log('WebSocket closed:', event);
            scheduleReconnect(); // Attempt to reconnect
        };

        socket.onerror = (error) => {
            errorDisplay.innerText = 'WebSocket Error: ' + error;
            console.error('WebSocket error:', error);
        };
    }
    function scheduleReconnect() {
        if (!socketReady) { // Only attempt reconnect if not already connected/connecting
            reconnectTimeout = setTimeout(() => {
                console.log(`Attempting to reconnect (attempt ${reconnectInterval/1000}s)...`);
                connectSocket();
                reconnectInterval = Math.min(reconnectInterval * 2, maxReconnectInterval); // Exponential backoff
            }, reconnectInterval);
        }
    }

    connectSocket(); // Initial connection

    document.getElementById('reconnectButton').addEventListener('click', () => {
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close(); // Close any existing connection first
        }
      //Don't call connect socket directly.  Call scheduleReconnect.
        scheduleReconnect(); // Manually trigger a reconnect attempt
    });

    const pressedKeys = {}; // Keep track of pressed keys

     function sendCommand(command) {
        if (socketReady) {
            console.log("Sending command:", JSON.stringify(command));
            socket.send(JSON.stringify(command)); //SEND THE JSON STRING
            currentCommandDisplay.innerText = `Current Command: ${JSON.stringify(command)}`;
            addToCommandHistory("Sent: " + JSON.stringify(command)); // Add to history
        } else {
            errorDisplay.innerText = "Cannot send command: Socket not connected.";
            console.log("Socket not ready, cannot send command:", command); // Log to console
        }
    }

    function addToCommandHistory(entry) {
        const commandElement = document.createElement('div');
        commandElement.innerText = entry;
        commandHistoryDiv.appendChild(commandElement);
        commandHistoryDiv.scrollTop = commandHistoryDiv.scrollHeight;
    }



    document.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            event.preventDefault();
        }

        if (pressedKeys[event.key]) return; // Prevent repeated triggers
        pressedKeys[event.key] = true;

        // Prevent default browser behavior for all relevant keys
        event.preventDefault();
        event.stopPropagation();

    let command = null;

    switch (event.key) {
        case 'ArrowLeft': command = { command: 'move', motor: 'base', direction: 'left' }; break;
        case 'ArrowRight': command = { command: 'move', motor: 'base', direction: 'right' }; break;
        case 'ArrowUp': command = { command: 'move', motor: 'shoulder', direction: 'up' }; break;
        case 'ArrowDown': command = { command: 'move', motor: 'shoulder', direction: 'down' }; break;
        case 'w': command = { command: 'move', motor: 'elbow', direction: 'up' }; break;
        case 's': command = { command: 'move', motor: 'elbow', direction: 'down' }; break;
        case 'a': command = { command: 'move', motor: 'wrist', direction: 'left' }; break;
        case 'd': command = { command: 'move', motor: 'wrist', direction: 'right' }; break;
        case 't': command = { command: 'move', motor: 'thumb', direction: 'inc' }; break;
        case 'g': command = { command: 'move', motor: 'thumb', direction: 'dec' }; break;
        case 'y': command = { command: 'move', motor: 'hand', direction: 'inc' }; break;
        case 'h': command = { command: 'move', motor: 'hand', direction: 'dec' }; break;
    }

    if (command) {
        sendCommand(command);
        currentCommandDisplay.innerText = `Current Command: ${JSON.stringify(command)}`;
    }
});


document.addEventListener('keyup', (event) => {
    pressedKeys[event.key] = false;
    currentCommandDisplay.innerText = `Current Command: None`;

    let command = null;

    switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowRight': command = { command: 'stop', motor: 'base' }; break;
        case 'ArrowUp':
        case 'ArrowDown':  command = { command: 'stop', motor: 'shoulder' }; break;
        case 'w':
        case 's':          command = { command: 'stop', motor: 'elbow' }; break;
        case 'a':
        case 'd':          command = { command: 'stop', motor: 'wrist' }; break;
        case 't':          command = { command: 'stop', motor: 'thumb' }; break; // Stop Thumb
        case 'g':          command = { command: 'stop', motor: 'thumb' }; break; // Stop Thumb
        case 'y':          command = { command: 'stop', motor: 'hand' }; break;  // Stop Hand
        case 'h':          command = { command: 'stop', motor: 'hand' }; break;  // Stop Hand
    }

    if (command) {
        sendCommand(command);
    }
});



    // --- Gamepad Support ---
    let gamepadIndex = null;


const DEAD_ZONE = 0.4; // Ignore small joystick movements (increased from 0.2)
const MOVE_DELAY = 200; // Minimum time between movement commands (in ms)
let lastMoveTime = 0;
let lastCommands = {}; // Track last commands sent to prevent duplicates
let wristDirection = 1; // 1 = clockwise, -1 = counterclockwise
let thumbDirection = 1; // 1 = open, -1 = close
let handDirection = 1;  // 1 = open, -1 = close
let lastThumbTrigger = 0;
let lastHandTrigger = 0;




window.addEventListener("gamepadconnected", (event) => {
    console.log("Gamepad connected:", event.gamepad);
    updateGamepadStatus(true);
    requestAnimationFrame(updateGamepad);
});

window.addEventListener("gamepaddisconnected", (event) => {
    console.log("Gamepad disconnected:", event.gamepad);
    updateGamepadStatus(false);
});


function updateGamepadStatus(connected) {
    const gamepadStatus = document.getElementById("gamepad-status");
    const gamepadButton = document.getElementById("gamepad-toggle");

    if (connected) {
        gamepadStatus.innerText = "Gamepad: Connected 🎮";
        gamepadButton.innerText = "Disconnect Gamepad";
        gamepadButton.style.display = "block"; // Show the button
    } else {
        gamepadStatus.innerText = "Gamepad: Not Connected ❌";
        gamepadButton.innerText = "Connect Gamepad";
        gamepadButton.style.display = "none"; // Hide the button if no gamepad
    }
}

function disconnectGamepad() {
    console.log("Gamepad disconnected manually.");
    updateGamepadStatus(false);
}


function updateGamepad() {
    const gamepads = navigator.getGamepads();
    if (!gamepads[0]) return; // No gamepad connected

    const gp = gamepads[0]; // Assuming one gamepad
    const now = Date.now();
    let command = null;

    // **LEFT STICK - Base Rotation & Shoulder Movement**
    let lx = gp.axes[0]; // Left stick horizontal (base rotation)
    let ly = gp.axes[1]; // Left stick vertical (shoulder)

    if (Math.abs(lx) > DEAD_ZONE) {
        command = { command: "move", motor: "base", direction: lx > 0 ? "right" : "left" };
    } else if (lastCommands["base"] !== "stop") {
        command = { command: "stop", motor: "base" };
    }

    if (Math.abs(ly) > DEAD_ZONE) {
        command = { command: "move", motor: "shoulder", direction: ly > 0 ? "down" : "up" };
    } else if (lastCommands["shoulder"] !== "stop") {
        command = { command: "stop", motor: "shoulder" };
    }

    // **RIGHT STICK - Elbow & Wrist**
    let rx = gp.axes[2]; // Right stick horizontal (wrist)
    let ry = gp.axes[3]; // Right stick vertical (elbow)

    if (Math.abs(rx) > DEAD_ZONE) {
        command = { command: "move", motor: "wrist", direction: rx > 0 ? "right" : "left" };
    } else if (lastCommands["wrist"] !== "stop") {
        command = { command: "stop", motor: "wrist" };
    }

    if (Math.abs(ry) > DEAD_ZONE) {
        command = { command: "move", motor: "elbow", direction: ry > 0 ? "down" : "up" };
    } else if (lastCommands["elbow"] !== "stop") {
        command = { command: "stop", motor: "elbow" };
    }

    // **LEFT TRIGGER (LT) for Hand Toggle**
    let lt = gp.buttons[6].value;
    if (lt > DEAD_ZONE && lastHandTrigger <= DEAD_ZONE) {
        handDirection *= -1; // Toggle direction
        command = { command: "move", motor: "hand", direction: handDirection > 0 ? "inc" : "dec" };
    } else if (lt <= DEAD_ZONE && lastHandTrigger > DEAD_ZONE) {
        command = { command: "stop", motor: "hand" };
    }
    lastHandTrigger = lt;

    // **RIGHT TRIGGER (RT) for Thumb Toggle**
    let rt = gp.buttons[7].value;
    if (rt > DEAD_ZONE && lastThumbTrigger <= DEAD_ZONE) {
        thumbDirection *= -1; // Toggle direction
        command = { command: "move", motor: "thumb", direction: thumbDirection > 0 ? "inc" : "dec" };
    } else if (rt <= DEAD_ZONE && lastThumbTrigger > DEAD_ZONE) {
        command = { command: "stop", motor: "thumb" };
    }
    lastThumbTrigger = rt;

    if (command && now - lastMoveTime > MOVE_DELAY) {
        sendCommand(command);
        console.log("Gamepad Command:", command);
        lastMoveTime = now;
        lastCommands[command.motor] = command.command;
    }

    requestAnimationFrame(updateGamepad);
}





window.addEventListener("load", () => {
    setTimeout(checkForGamepads, 500); // Delay to allow browser to detect gamepads
});

window.addEventListener("gamepadconnected", (event) => {
    console.log("Gamepad connected:", event.gamepad);
    updateGamepadStatus(true);
    requestAnimationFrame(updateGamepad);
});

window.addEventListener("gamepaddisconnected", (event) => {
    console.log("Gamepad disconnected:", event.gamepad);
    updateGamepadStatus(false);
});

function checkForGamepads() {
    const gamepads = navigator.getGamepads();
    if (gamepads[0]) {
        console.log("Gamepad detected on page load.");
        updateGamepadStatus(true);
        requestAnimationFrame(updateGamepad);
    }
}


function updateGamepadStatus(connected) {
    const gamepadStatus = document.getElementById("gamepad-status");
    const gamepadButton = document.getElementById("gamepad-toggle");

    if (connected) {
        gamepadStatus.innerText = "Gamepad: Connected 🎮";
        gamepadButton.innerText = "Disconnect Gamepad";
        gamepadButton.style.display = "block"; // Show the button
    } else {
        gamepadStatus.innerText = "Gamepad: Not Connected ❌";
        gamepadButton.innerText = "Connect Gamepad";
        gamepadButton.style.display = "none"; // Hide the button if no gamepad
    }
}


    function gameLoop() {
        if (gamepadIndex !== null) {
            const gamepad = navigator.getGamepads()[gamepadIndex];
            if (gamepad) {
                // Left Joystick (Base and Shoulder)
                const leftX = gamepad.axes[0];
                const leftY = gamepad.axes[1];

                if (Math.abs(leftX) > 0.1) {
                    sendCommand({command: 'move', motor: 'base', direction: leftX > 0 ? 'right' : 'left'});
                } else {
                    sendCommand({command: 'stop', motor: 'base'});
                }

                if (Math.abs(leftY) > 0.1) {
                    sendCommand({command: 'move', motor: 'shoulder', direction: leftY > 0 ? 'down' : 'up'});
                } else {
                    sendCommand({command: 'stop', motor: 'shoulder'});
                }

                // Right Joystick (Elbow and Wrist)
                const rightX = gamepad.axes[3];
                const rightY = gamepad.axes[4];

                if (Math.abs(rightX) > 0.1) {
                    sendCommand({command: 'move', motor: 'wrist', direction: rightX > 0 ? 'right' : 'left'});
                } else {
                    sendCommand({command: 'stop', motor: 'wrist'});
                }

                if (Math.abs(rightY) > 0.1) {
                    sendCommand({command: 'move', motor: 'elbow', direction: rightY > 0 ? 'down' : 'up'});
                } else {
                    sendCommand({command: 'stop', motor: 'elbow'});
                }

                // Triggers (Hand and Thumb)
                const leftTrigger = gamepad.buttons[6].value;
                const rightTrigger = gamepad.buttons[7].value;

                if (leftTrigger > 0.2) {
                    sendCommand({command: 'move', motor: 'hand', direction: 'down'}); // Assuming max_pos is closed
                } else {
                    sendCommand({command: 'stop', motor: 'hand'});
                }
                if (rightTrigger > 0.2) {
                     sendCommand({command: 'move', motor: 'thumb', direction: 'down'}); // Assuming max_pos is closed
                } else {
                    sendCommand({command: 'stop', motor: 'thumb'});
                }
            }
        }
        requestAnimationFrame(gameLoop);
    }

</script>
</body>
</html>
